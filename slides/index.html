<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>DRY in Angular Templates: Content Projection im Praxiseinsatz</title>

    <link rel="stylesheet" href="css/reset.css" />
    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/theme/night.css" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />

    <!-- Custom styling and tweaks -->
    <link rel="stylesheet" href="css/style.min.css" />

    <!-- Plugins -->
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
  </head>
  <body>
    <div class="reveal">
      <div class="footer">FOOTER Use left and right arrows to navigate</div>

      <div class="slides">
        <section>
          <h2>DRY in Angular Templates: Content Projection im Praxiseinsatz</h2>
          <h3>Martin Grotz</h3>
          <div>TODO: MATHEMA Logo, Code Days Logo</div>
          <aside class="notes"></aside>
        </section>

        <section>
          <div class="placeholder">
            <!-- TODO: Logo von Angular -->
            <img src="img/100px_placeholder.png" style="" />
          </div>
          <div>
            <h3>Angular</h3>
            <ul>
              <li>Framework</li>
              <li>Webtechnologien & TypeScript</li>
              <li>Komponentenorientiert</li>
              <li>Dependency Injection</li>
              <li>Automatische Change Detection</li>
            </ul>
          </div>
          <aside class="notes">
            <ul>
              <li>
                Multi-target: Webapps, Server-side rendering, Mobile Apps via
                Ionic
              </li>

              
            </ul>
          </aside>
        </section>

        <section>
          <h3>Angular Bausteine</h3>
          <pre><code class="typescript" data-trim data-noescape>@Directive({selector: '[bold]'})
export class SomeDirective {
    @Input() 
    @HostBinding('class.bold')
    bold: boolean = false;
}

@Injectable()
export class SimpleService {
    public shouldBeBold = true;
}

@Component(
    {
        selector: 'app-my-component',
        template: `
        &lt;h1&gt;My Component&lt;/h1&gt;
        &lt;p [bold]=&quot;true&quot;&gt;This text can be bold (or not)?&lt;/p&gt;
        `
    }
)
export class MyComponent {}
          </code></pre>

          <aside class="notes">
            <ul>
              <li>
                Angular-Anwendung besteht aus drei Sachen:
                <ul>
                  <li>
                    Komponenten, die als View f√ºr die Darstellung zust√§ndig sind
                  </li>
                  <li>
                    Direktiven, die das Verhalten von Komponenten beeinflussen
                  </li>
                  <li>
                    Services, die f√ºr Datenhaltung und -austausch zust√§ndig sind
                  </li>
                </ul>
              </li>
              <li>
                Angular macht viel √ºber Decorators: Aspektorientierte
                Programmierung
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Dependency Injection</h3>
          <pre><code class="typescript" data-trim data-noescape>@Directive({selector: '[bold]'})
export class SomeDirective {
    @Input() 
    @HostBinding('class.bold')
    bold: boolean = false;
}

@Injectable()
export class SimpleService {
    public shouldBeBold = true;
}

@Component(
    {
        selector: 'app-my-component',
        <mark>providers: [SimpleService]</mark>,
        template: `
        &lt;style&gt;.bold { font-weight: bold}&lt;/style&gt;
        &lt;h1&gt;My Component&lt;/h1&gt;
        &lt;p <mark>[bold]=&quot;simpleService.shouldBeBold&quot;</mark>&gt;This text can be bold (or not)?&lt;/p&gt;`
    }
)
export class MyComponent {
    <mark>constructor(public readonly simpleService: SimpleService)</mark> {}
  }</code></pre>

          <aside class="notes">
            <ul>
              <li>
                Dependency injection: Provider und automatische Injection in den
                Konstruktor
              </li>
            </ul>
          </aside>
        </section>

        <section><h3>Change Detection - Default</h3>
          
          <div class="fragment"><img src="img/Angular_ChangeDetection_default.gif"></div>

          <aside class="notes">
            <ul><li>
              <ul>
                <li>Probleme und Vorteile mit Default</li>
              </ul>
            </li></ul>
          </aside>
        </section>

        <section><h3>Change Detection - OnPush</h3>
          <div class="fragment"><img src="img/Angular_ChangeDetection_OnPush.gif"></div>
          
          <aside class="notes">
            <ul><li>
              <ul>
                <li>Probleme</li>
                <li>Default vs OnPush</li>
                <li>OnPush: </li>
                <li>Mit OnPush:
                  <ul>
                    <li>√Ñnderung an Input: Nur wo sich Objektreferenzen ge√§ndert haben, wird der Baum gepr√ºft</li>
                    <li>Vergleich von Objektreferenzen, z.B. √Ñnderung von Daten IM Array oder Objekt f√§llt nicht auf -> ggf. sowas wie Immutable.js oder Object.assign verwenden</li></li>
                    <li>Input √§ndert sich: Teilbaum wird gepr√ºft</li>
                    <li>Event: Alles wird gepr√ºft -> manchmal wird was nicht aktualisiert, bis man klickt -> OnPush Problem</li>
                    <li>bei bestimmten Funktionen (setTimeout(), Promise.resolve().then(), obs$.subscribe()) muss man bei OnPush manuell CD ausl√∂sen!</li>
                  </ul>
              </ul>
            </li></ul>
          </aside>
        </section>

        <section>
          <h3>ng-content</h3>

          <div class="flex centered">
            <div class="code fragment">
            <pre><code class="typescript" data-trim data-noescape>@Component(
    {
        selector: 'outer-component',
        template: `
        &lt;h1&gt;...&lt;/h1&gt;
        &lt;fancy-modal&gt;
            &lt;p&gt;
                Lorem ipsum dolor sit amet. 
                Duis a ornare massa.
            &lt;/p&gt;
        &lt;/fancy-modal&gt;
        `
    }
)
export class OuterComponent {/* ... */}
              </code></pre>
            </div>
            <div class="code fragment">
              <pre><code class="typescript" data-trim data-noescape>@Component(
    {
        selector: 'fancy-modal',
        template: `
        &lt;header&gt;...&lt;/header&gt;
        &lt;ng-content&gt;
        
        &lt;/ng-content&gt;
        &lt;footer&gt;...&lt;/footer&gt;
        `
    }
)
export class FancyModal {/* ... */}
              </code></pre>
            </div>

            <svg class="fragment" style="position: absolute;" height="100%" width="100%">
              <defs>
                  <marker id="markerArrow" markerWidth="13" markerHeight="13" refX="2" refY="6"
                         orient="auto">
                      <path d="M2,2 L2,11 L10,6 L2,2" style="fill: #ffff00;" />
                  </marker>
              </defs>
              
              <line x1="495" y1="170" x2="650" y2="145" class="arrow" />

              <rect x="225" y="130" width="270" height="70"
  style="fill:transparent;stroke:yellow;stroke-width:2;fill-opacity:0.1;stroke-opacity:1" />
            </svg>
          </div>

          <aside class="notes">
            <ul>
             
            </ul>
          </aside>

          <aside class="notes">
            <ul>
              <li>Statische Projektion</li>
              <li>
                Zu projizierender Inhalt wird einfach zwischen die Tags des
                Wrapper-Elements geschrieben
              </li>
              <li>
                Element wird an einer Stelle ausgeschnitten und an anderer
                wieder eingef√ºgt
              </li>
              <li>
                Beispiel: Wrapper-Komponente mit Funktionalit√§t, wechselnder
                Inhalt
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <h3 style="font-size: 2rem">
            ng-content mit select
          </h3>

          <!-- Neuer Inhalt: Auflistung Selektoren ohne Code-Beispiele -->
          <div class="code fragment">
            <pre class="fit-content"><code class="typescript" data-trim data-noescape>@Component(
    {
        /* ... */
        template: `
            &lt;ng-content select=&quot;p&quot;&gt;&lt;/ng-content&gt;
            &lt;ng-content select=&quot;.my-class&quot;&gt;&lt;/ng-content&gt;
            &lt;ng-content select=&quot;[attr]&quot;&gt;&lt;/ng-content&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        `
    }
)
export class WithSelectors {/* ... */}
      </code></pre>
    </div>
          
          <aside class="notes">
            <ul>
            
              <li>
                In ng-content kann mit select ein CSS-Selektor angegeben werden,
                der dann nur passende Inhalte in diesem ng-content anzeigt
              </li>
              <li>
                Wenn man keinen "Lumpensammler" ohne select hat, werden ggf.
                nirgends passende Inhalte dann auch nirgends angezeigt
              </li>
            </ul>
          </aside>
        </section>


        <section>
          <h3>
            Angular Lifecycle Hooks
          </h3>

          <table>
            <thead>
              <tr>
                <th>Hook</th>
                <th>Was passiert</th>
              </tr>
            </thead>

            <tbody>
              <tr class="fragment">
                <td>ngOnInit</td>
                <td>Inputs initialisiert, Komponente initialisieren</td>
              </tr>
              <tr class="fragment">
                <td>ngAfterContentInit</td>
                <td>Externer Content wurde projiziert und initialisiert</td>
              </tr>
              <tr class="fragment">
                <td>ngAfterViewInit</td>
                <td>Eigenes Template und Kindkomponenten initialisiert</td>
              </tr>
              <tr class="fragment">
                <td>ngOnDestroy</td>
                <td>Komponente wird gleich abgebaut</td>
              </tr>
            </tbody>
          </table>

          <aside class="notes">
            <ul>
              <li>[Input] zum √úbergeben von Daten an Komponenten/Direktiven</li>
            </ul>
          </aside>
        </section>
        <section>
          <h3>Lifecycle Reihenfolge</h3>

          <!-- Zus√§tzliche Folie: Einfache Verschachtelung Komponenten, console.log, und vielleicht Diagramm? -->

          <div class="flex centered align-centered">
              
              <div class="code fragment">
                <pre class="fit-content"><code class="typescript unlimited-height" data-trim data-noescape>@Component(
    {
        selector: 'outer',
        template: `
            &lt;middle&gt;
                &lt;inner&gt;&lt;/inner&gt;
            &lt;/middle&gt;
        `
    }
)
export class OuterComponent {/* ... */}

@Component(
    {
        selector: 'middle',
        template: `&lt;ng-content&gt;&lt;/ng-content&gt;`
    }
)
export class MiddleComponent {/* ... */}

@Component(
    {
        selector: 'inner',
        template: `&lt;p&gt;...&lt;/p&gt;`
    }
)
export class InnerComponent {/* ... */}
              </code></pre>
            </div>
            <div class="fragment">
              <img src="img/screenshot-content-lifecycle-simple_01.png" />
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>
                Gef√§hrlich: In Lifecycle-Hooks ChangeDetection mit detectChanges
                erzwingen: Elternkomponenten sind noch nicht fertig
                initialisiert, ggf. unerwartete undefined Werte bei Inputs,
                ViewChild, ContentChild
              </li>
            </ul>
          </aside>
        </section>

<!-- Neue Folie: ContentChild/ContentChildren/QueryList erkl√§ren -->

        <section>
          <h3>ContentChildren</h3>

          <blockquote style="width:90%; font-size: 1.2rem;">Use to get the QueryList of elements or directives from the content DOM. Any time a child element is added, removed, or moved, the query list will be updated, and the changes observable of the query list will emit a new value.
<br><br>
            Content queries are set before the ngAfterContentInit callback is called.
<br><br>
            
            Does not retrieve elements or directives that are in other components' templates, since a component's template is always a black box to its ancestors.</blockquote>

            <div class="code fragment">
              <pre class="fit-content"><code class="typescript unlimited-height" style="font-size: 1rem;" data-trim data-noescape>@ContentChild(TagDirective) tagDirective: TagDirective;

@ContentChildren(TagDirective) tagDirectives: QueryList&lt;TagDirective&gt;;
</code></pre></div>
      
<p style="font-size: 1.2rem;">
Doku: <br>
<a href="https://angular.io/api/core/ContentChild">https://angular.io/api/core/ContentChild</a><br>
<a href="https://angular.io/api/core/ContentChildren">https://angular.io/api/core/ContentChildren</a>
</p>
          <aside class="notes">
            <ul>
              <li>Variante, um genau ein Element (das erste gefundene!) zu selektieren: ContentChild</li>
              <li>ContentChild ist erst nach AfterContentInit bef√ºllt, falls
                vorhanden</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Projektion √ºber mehrere Ebenen</h3>

          <div class="flex">
          <div class="fragment">
          <pre class="fit-content"><code class="typescript unlimited-height smaller-font" data-trim data-noescape>@Component(
    {
        selector: 'layer1',
        template: `
            &lt;layer2&gt;
                &lt;div <mark>[tag]="'tagged'"</mark>&gt;Cool content&lt;/div&gt;
            &lt;/layer2&gt;
        `
    }
)
export class FirstLayerComponent {}

@Component(
    {
        selector: 'layer2',
        template: `
        &lt;layer3&gt;
            &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/layer3&gt;`
    }
)
export class SecondLayerComponent {
    @ContentChild(TagDirective) tagDirective!: TagDirective;

    ngAfterContentInit(): void {
        console.log('SecondLayerComponent', this.tagDirective);
    }
}

@Component(
    {
        selector: 'layer3',
        template: `&lt;ng-content&gt;&lt;/ng-content&gt;`
    }
)
export class ThirdLayerComponent {
    @ContentChild(TagDirective) tagDirective!: TagDirective;

    ngAfterContentInit(): void {
        console.log('ThirdLayerComponent', this.tagDirective);
    }
}
          </code></pre>
        </div>

<div>
  <img class="fragment" src="img/screenshot-content-children-mehrere-ebenen-browser_01.png" />
  <img class="fragment" src="img/screenshot-content-children-mehrere-ebenen_01.png" />
</div>
</div>

          <aside class="notes">
            <ul>
              <li>Klappt nur bei Weitergabe #1, danach ist es undefined.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3 style="font-size: 2rem">
            2x ng-content mit gleichem Selektor = üí•
          </h3>

          <div class="flex">
            <div><img src="img/ng-content-projecting-twice_01.png" /></div>

            <div class="flex-column">
              <div class="fragment">
                <img src="img/app-content-twice-both-true_01.png" />
              </div>
              <div class="fragment">
                <img src="img/screenshot-projecting-twice-both-true_01.png" />
              </div>
            </div>

            <div class="flex-column">
              <div class="fragment">
                <img src="img/app-content-twice-second-false_01.png" />
              </div>
              <div class="fragment">
                <img
                  src="img/screenshot-projecting-twice-second-false_01.png"
                />
              </div>
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Ausschneiden aus dem DOM, nur 1x m√∂glich</li>
              <li>Letztes ng-content gewinnt</li>
              <li>
                Egal, ob das ng-content zur Laufzeit √ºberhaupt da ist oder
                nicht!
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Neuer Inhalt: Vereinfachte Code-Beispiele als Code, R√ºckverweis auf Dependency Injection -->
          <h3 style="font-size: 2rem">Injector (& Change Detection)</h3>

          <div class="flex">
          <div class="fragment">
          <pre class="fit-content"><code class="typescript unlimited-height smaller-font" data-trim data-noescape>@Component(
    {
        selector: 'layer-one',
        template: `&lt;layer-two&gt;<mark>&lt;is-injected&gt;&lt;/is-injected&gt;</mark>&lt;/layer-two&gt;`,
    }
)
export class LayerOneComponent {}

@Component(
    {
        selector: 'layer-two',
        template: `&lt;layer-three&gt;&lt;ng-content&gt;&lt;/ng-content&gt;&lt;/layer-three&gt;`,
        providers: [<mark class="first">FirstService</mark>]
    }
)
export class LayerTwoComponent {}

@Component(
    {
        selector: 'layer-three',
        template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
        providers: [<mark class="second">SecondService</mark>]
    }
)
export class LayerThreeComponent {}

@Component(
    {
        selector: '<mark>is-injected</mark>',
        template: `&lt;p&gt;Are both services injected here?&lt;/p&gt;`
    }
)
export class IsInjectedComponent {
    constructor(
        @Optional() firstService: <mark class="first">FirstService</mark>,
        @Optional() secondService: <mark class="second">SecondService</mark>
    ) {
        console.log('injected services', {firstService, secondService});
    }
}          </code></pre>
</div>

<div>
          <img class="fragment" src="img/screenshot-injector-mehrere-ebenen_01.png">
          <img class="fragment" src="img/injector-mehrere-ebenen_01.png">
          
        </div>
      </div>

          <aside class="notes">
            <ul>
              <li>
                DOM mit ng-content ist nicht gleich Angular Injector/CD Tree
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Neuer Inhalt: Diagramm mit aktualisierten Komponentennamen -->
          <h3 style="font-size: 2rem">Injector (& Change Detection)</h3>

          <div class="flex">
          <div class="fragment">
            <pre class="fit-content"><code class="typescript unlimited-height" style="font-size: 0.5rem;" data-trim data-noescape>@Component(
      {
          selector: 'layer-one',
          template: `&lt;layer-two&gt;<mark>&lt;is-injected&gt;&lt;/is-injected&gt;</mark>&lt;/layer-two&gt;`,
      }
  )
  export class LayerOneComponent {}
  
  @Component(
      {
          selector: 'layer-two',
          template: `&lt;layer-three&gt;&lt;ng-content&gt;&lt;/ng-content&gt;&lt;/layer-three&gt;`,
          providers: [<mark class="first">FirstService</mark>]
      }
  )
  export class LayerTwoComponent {}
  
  @Component(
      {
          selector: 'layer-three',
          template: `&lt;ng-content&gt;&lt;/ng-content&gt;`,
          providers: [<mark class="second">SecondService</mark>]
      }
  )
  export class LayerThreeComponent {}
  
  @Component(
      {
          selector: '<mark>is-injected</mark>',
          template: `&lt;p&gt;Are both services injected here?&lt;/p&gt;`
      }
  )
  export class IsInjectedComponent {
      constructor(
          @Optional() firstService: <mark class="first">FirstService</mark>,
          @Optional() secondService: <mark class="second">SecondService</mark>
      ) {
          console.log('injected services', {firstService, secondService});
      }
  }          </code></pre>
  </div>

          <div class="flex-column align-centered">
             


              <blockquote class="fragment" style="font-size: 0.9rem">
                This is working as expected: <br />
                nodes are only "projected" (moved to a different location) but
                everything else works relative to their source (= before
                projection) location.
              </blockquote>
            <div class="fragment" style="width: 100%">
              <img src="img/injector-tree_01.png" />
            </div>
          </div>

        </div>

          <aside class="notes"></aside>
        </section>

        <section>
          <h3>ng-template</h3>
          <aside class="notes">
            <ul>
              <li>
                Kein Ausschneiden und Einf√ºgen, sondern dynamisches Erzeugen aus
                Vorlagen
              </li>
              <li>
                Alles, was mit ng-content geht, geht auch mit ng-template, aber
                ggf. mehr Code
              </li>
              <li>Mehr M√∂glichkeiten als ng-content</li>
            </ul>
          </aside>
        </section>

          <!-- Beispiel mit *ngIf und template als else -->

        <section>
          <!-- Neuer Inhalt: Vereinfachtes Codebeispiel, ngTemplateOutlet ohne first und index, nur mit $implicit, und nicht alles item nennen? -->
          <h3>ngTemplateOutlet</h3>

          <div class="flex">
            <div class="flex-column" style="align-items: center">
              <div class="fragment" data-fragment-index="1">
                <img src="img/ng-template-context_01.png" />
              </div>
              <div class="fragment" data-fragment-index="3" style="width: 50%">
                <img src="img/screenshot-list-different-ng-template_01.png" />
              </div>
            </div>

            <div class="fragment" data-fragment-index="2">
              <img src="img/list-different-ng-template_01.png" />
            </div>
          </div>
        </section>

        <section>
          <h3>Lifecycle</h3>

          <!-- Die Folie kann glaub ich so bleiben? Vielleicht Code im neuen Stil -->

          <div class="flex">
            <div class="fragment" style="width: 80%">
              <img src="img/list-different-ng-template_01.png" />
            </div>
            <div class="fragment">
              <img src="img/list-different-ng-template-lifecycle_01.png" />
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Gleiche Komponente wie gerade eben</li>
              <li>
                Nur der dynamische Teil mit reingegebenem Template interessant
              </li>
              <li>
                Direkt vor "ngAfterViewInit" wird der dynamische Teil komplett
                erzeugt und initialisiert
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Eigene Folie f√ºr TemplateTypeDirective und Beispiel-Templates mit Screenshots der beiden! -->
          <h3 style="font-size: 2rem">Verschiedene Templates mit Auswahl</h3>

          <!-- Zweite Folie: Selektion via QueryList und Templates in Map speichern -->
          <!-- Dritte Folie: Template und Endergebnis -->
          <div class="flex">
            <div class="flex-column">
              <div class="fragment">
                <img src="img/ng-template-multiple-types_01.png" />
              </div>
              <div class="fragment">
                <img src="img/template-type-directive_01.png" />
              </div>
            </div>
            <div class="fragment">
              <img src="img/list-multiple-templates_01.png" />
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>
                Gibt es kein passendes Template, wird stillschweigend einfach
                nichts angezeigt
              </li>
              <li>
                If you are listening to QueryList's observable updates things
                are not as clear cut: updates are often late, and already
                removed things are still showing up - and the order is never
                guaranteed!
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Neuer Code-Stil, zweite Folie: Bild DOM-Tree&Angular-Tree: Alles wie es sein soll -->
          <h3 style="font-size: 2rem">Injector Tree</h3>

          <div class="flex" style="margin-top: -40px">
            <div class="flex-column">
              <div class="fragment">
                <img src="img/ng-template-injector_01.png" />
              </div>
              <div class="fragment" style="margin-top: -40px">
                <img src="img/list-injector_01.png" />
              </div>
            </div>
            <div class="flex-column">
              <div class="fragment">
                <img src="img/list-item-injector_01.png" />
              </div>
              <div class="fragment">
                <img src="img/screenshot-list-item-injector_01.png" />
              </div>
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Hier wird nichts ausgeschnitten und verschoben</li>
              <li>Injector verh√§lt sich so, wie erwartet</li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- *ngFor zeigen/erkl√§ren und default trackBy mit GIF -->
          <h3>trackBy</h3>
          <span style="font-size: 0.5rem" class="placeholder"
            >TODO: trackBy mit in Bild √ºbernehmen, damit man wei√ü, wo es
            hinkommt</span
          >

          <div class="flex">
            <div class="fragment">
              <img src="img/ng-template-wrapper-trackBy_01.png" />
            </div>

            <div class="flex-column fragment">
              <div>
                <img src="img/app-list-injector-default-trackBy_01.png" />
              </div>
              <div>
                <img src="img/no-trackBy-items-get-recreated_01_endless.gif" />
              </div>
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Angepasstes trackBy, z.B. auf eine id</li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- angepasstes trackBy zeigen, GIF mit Jetzt funktioniert's -->
          <h3>trackBy</h3>

          <div class="flex-column">
            <div class="fragment">
              <img src="img/app-list-injector-custom-trackBy_01.png" />
            </div>
            <div class="fragment">
              <img src="img/custom-trackBy-items-kept_01_endless.gif" />
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Angepasstes trackBy, z.B. auf eine id</li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Neue Folie: Kurze Einf√ºhrung Google Performance Tab, Screenshot wo zu finden, Flamecharts Makroansicht zeigen -->
          <!-- Dann erst Beispiel aus Projekt rangezoomed -->
          <h3>Performance</h3>

          <img src="img/performance-creating-items_01.png" />

          <aside class="notes">
            <ul>
              <li>Niemals ohne OnPush arbeiten</li>
              <li>Zerst√∂ren/Aufbauen teuer: custom trackBy</li>
              <li>Komponenten/Direktiven m√∂glichst schlank halten</li>
              <li>Jede Direktive, jeder Input, jedes ngIf kostet</li>
              <li>rx-angular</li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Bisschen weniger h√§ssliches Layout -->
          <h3>Doku-Links</h3>

          <a
            href="https://angular.io/guide/structural-directives#the-ng-template"
            >Offizielle Doku zu ng-template</a
          >
          <br />
          <br />
          <a
            href="https://medium.com/claritydesignsystem/ng-content-the-hidden-docs-96a29d70d11b"
            >ng-content: The hidden docs</a
          >
          <br />
          <br />
          <a
            href="https://blog.angular-university.io/angular-ng-template-ng-container-ngtemplateoutlet/"
            >Angular ng-template, ng-container and ngTemplateOutlet - The
            Complete Guide To Angular Templates</a
          >
          <br />
          <br />
        </section>

        <section>
          <h3 class="placeholder">Fragen/Danke</h3>
          TODO: Kontaktdaten & Bild
        </section>
      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.configure({
        transition: "none",
        history: "true",
      });
      Reveal.initialize({
        hashOneBasedIndex: false,
        controls: false,
        slideNumber: "c/t",
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
