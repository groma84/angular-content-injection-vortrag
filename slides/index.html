<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>DRY in Angular Templates: Content Projection im Praxiseinsatz</title>

    <link rel="stylesheet" href="css/reset.css" />
    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/theme/night.css" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />

    <!-- Custom styling and tweaks -->
    <link rel="stylesheet" href="css/style.min.css" />

    <!-- Plugins -->
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
  </head>
  <body>
    <div class="reveal">
      <div class="footer">FOOTER Use left and right arrows to navigate</div>

      <div class="slides">
        <section>
          <h2>DRY in Angular Templates: Content Projection im Praxiseinsatz</h2>
          <h3>Martin Grotz</h3>
          <div>TODO: MATHEMA Logo, Code Days Logo</div>
          <aside class="notes"></aside>
        </section>

        <section>
          <div class="placeholder">
            <!-- TODO: Logo von Angular -->
            <img src="img/100px_placeholder.png" style="" />
          </div>
          <div>
            <h3>Angular</h3>
            <ul>
              <li>Framework</li>
              <li>Webtechnologien & TypeScript</li>
              <li>Komponentenorientiert</li>
              <li>Dependency Injection</li>
              <li>Automatische Change Detection</li>
            </ul>
          </div>
          <aside class="notes">
            <ul>
              <li>
                Multi-target: Webapps, Server-side rendering, Mobile Apps via
                Ionic
              </li>

              
            </ul>
          </aside>
        </section>

        <section>
          <h3>Angular Bausteine</h3>
          <pre><code class="typescript" data-trim data-noescape>@Directive({selector: '[bold]'})
export class SomeDirective {
    @Input() 
    @HostBinding('class.bold')
    bold: boolean = false;
}

@Injectable()
export class SimpleService {
    public shouldBeBold = true;
}

@Component(
    {
        selector: 'app-my-component',
        template: `
        &lt;h1&gt;My Component&lt;/h1&gt;
        &lt;p [bold]=&quot;true&quot;&gt;This text can be bold (or not)?&lt;/p&gt;
        `
    }
)
export class MyComponent {}
          </code></pre>

          <aside class="notes">
            <ul>
              <li>
                Angular-Anwendung besteht aus drei Sachen:
                <ul>
                  <li>
                    Komponenten, die als View für die Darstellung zuständig sind
                  </li>
                  <li>
                    Direktiven, die das Verhalten von Komponenten beeinflussen
                  </li>
                  <li>
                    Services, die für Datenhaltung und -austausch zuständig sind
                  </li>
                </ul>
              </li>
              <li>
                Angular macht viel über Decorators: Aspektorientierte
                Programmierung
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Dependency Injection</h3>
          <pre><code class="typescript" data-trim data-noescape>@Directive({selector: '[bold]'})
export class SomeDirective {
    @Input() 
    @HostBinding('class.bold')
    bold: boolean = false;
}

@Injectable()
export class SimpleService {
    public shouldBeBold = true;
}

@Component(
    {
        selector: 'app-my-component',
        <mark>providers: [SimpleService]</mark>,
        template: `
        &lt;style&gt;.bold { font-weight: bold}&lt;/style&gt;
        &lt;h1&gt;My Component&lt;/h1&gt;
        &lt;p <mark>[bold]=&quot;simpleService.shouldBeBold&quot;</mark>&gt;This text can be bold (or not)?&lt;/p&gt;`
    }
)
export class MyComponent {
    <mark>constructor(public readonly simpleService: SimpleService)</mark> {}
  }</code></pre>

          <aside class="notes">
            <ul>
              <li>
                Dependency injection: Provider und automatische Injection in den
                Konstruktor
              </li>
            </ul>
          </aside>
        </section>

        <section><h3>Change Detection - Default</h3>
          
          <div class="fragment"><img src="img/Angular_ChangeDetection_default.gif"></div>

          <aside class="notes">
            <ul><li>
              <ul>
                <li>Probleme und Vorteile mit Default</li>
              </ul>
            </li></ul>
          </aside>
        </section>

        <section><h3>Change Detection - OnPush</h3>
          <div class="fragment"><img src="img/Angular_ChangeDetection_OnPush.gif"></div>
          
          <aside class="notes">
            <ul><li>
              <ul>
                <li>Probleme</li>
                <li>Default vs OnPush</li>
                <li>OnPush: </li>
                <li>Mit OnPush:
                  <ul>
                    <li>Änderung an Input: Nur wo sich Objektreferenzen geändert haben, wird der Baum geprüft</li>
                    <li>Vergleich von Objektreferenzen, z.B. Änderung von Daten IM Array oder Objekt fällt nicht auf -> ggf. sowas wie Immutable.js oder Object.assign verwenden</li></li>
                    <li>Input ändert sich: Teilbaum wird geprüft</li>
                    <li>Event: Alles wird geprüft -> manchmal wird was nicht aktualisiert, bis man klickt -> OnPush Problem</li>
                    <li>bei bestimmten Funktionen (setTimeout(), Promise.resolve().then(), obs$.subscribe()) muss man bei OnPush manuell CD auslösen!</li>
                  </ul>
              </ul>
            </li></ul>
          </aside>
        </section>

        <section>
          <h3>ng-content</h3>
          <aside class="notes">
            <ul>
              <li>Statische Projektion</li>
              <li>
                Zu projizierender Inhalt wird einfach zwischen die Tags des
                Wrapper-Elements geschrieben
              </li>
              <li>
                Element wird an einer Stelle ausgeschnitten und an anderer
                wieder eingefügt
              </li>
              <li>
                Beispiel: Wrapper-Komponente mit Funktionalität, wechselnder
                Inhalt
              </li>
            </ul>
          </aside>
        </section>

        <section>
<!-- Neuer Inhalt: Vereinfachte Komponenten mit ng-content + Bilder mit Vorher Nachher Ausgeschnitten (oder sogar animiert?) -->

          <div class="flex">
            <div>
              <img src="img/app-modal-simple_01.png" />
            </div>
            <div class="flex-column">
              <img class="fragment" src="img/app-ng-content-simple_01.png" />
              <img class="fragment" src="img/screenshot-simple-modal.png" />
            </div>
          </div>
          <aside class="notes">
            <ul>
              <li>
                Inhalt zwischen den Tags wird ausgeschnitten und an der Stelle
                mit ng-content im Modalen Dialog eingefügt
              </li>
              <li>Der eingefügte Inhalt kann beliebig sein</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3 style="font-size: 2rem">
            &lt;ng-content select="..."&gt;&lt;/ng-content&gt;
          </h3>

          <!-- Neuer Inhalt: Auflistung Selektoren ohne Code-Beispiele -->

          <div class="flex-column">
            <div class="flex">
              <div class="fragment" style="width: 60%">
                <img src="img/app-ng-content-selectors_01.png" />
              </div>
              <div class="fragment" style="width: 50%">
                <img src="img/app-modal-selectors_01.png" />
              </div>
            </div>

            <div class="fragment" style="width: 65%">
              <img src="img/screenshot-modal-selectors_01.png" />
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>
                Verschiedene Komponenten, die jeweils wieder irgendwas enthalten
              </li>
              <li>
                app-text-wrapper enthält nochmal eine Unterkompomente app-text
                mit einem Paragraph drin
              </li>
              <li>
                In ng-content kann mit select ein CSS-Selektor angegeben werden,
                der dann nur passende Inhalte in diesem ng-content anzeigt
              </li>
              <li>
                Wenn man keinen "Lumpensammler" ohne select hat, werden ggf.
                nirgends passende Inhalte dann auch nirgends angezeigt
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Lifecycle Reihenfolge</h3>

          <!-- Neuer Inhalt: Hooks erklären und relevante auflisten -->
          <!-- Zusätzliche Folie: Einfache Verschachtelung Komponenten, console.log, und vielleicht Diagramm? -->

          <div class="flex">
            <div class="fragment">
              <img src="img/ng-content-lifecycle-elements_01.png" />
            </div>
            <div class="fragment">
              <img src="img/ng-content-lifecycle_01.png" />
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>
                Angular Lifecycle Hooks:
                <ol>
                  <li>ngOnInit: Inputs</li>
                  <li>ngAfterContentInit: statischer Content</li>
                  <li>
                    ngAfterContentChecked: Change Detection im statischen
                    Content
                  </li>
                  <li>ngAfterViewInit: dynamischer Content</li>
                  <li>
                    ngAfterViewChecked: Change Detection im dynamischen Content
                  </li>
                </ol>
              </li>
              <li>
                Mit ng-content muss beachtet werden, dass jede Lifecycle-Phase
                "depth first" initialisiert wird
              </li>
              <li>
                Bei mehrfacher Verschachtelung wird es unübersichtlich (siehe
                text in text-wrapper, und list-item in text)
              </li>
              <li>
                Gefährlich: In Lifecycle-Hooks ChangeDetection mit detectChanges
                erzwingen: Elternkomponenten sind noch nicht fertig
                initialisiert, ggf. unerwartete undefined Werte bei Inputs,
                ViewChild, ContentChild
              </li>
            </ul>
          </aside>
        </section>

<!-- Neue Folie: ContentChild/ContentChildren/QueryList erklären -->


        <section>
          <!-- Neuer Inhalt: Vereinfachter Code, zeigen dass mit ng-content nur eine Ebene tief was gefunden wird (descendants von ebene1 auf 2 möglich?) -->
          <h3 style="font-size: 2rem">Projektion über mehrere Ebenen</h3>

          <div class="flex" style="margin-top: -40px">
            <div class="flex-column">
              <div><img src="img/screenshot-two-layers_01.png" /></div>
              <div class="fragment">
                <img src="img/ng-content-two-layers_01.png" />
              </div>
            </div>
            <div>
              <div class="fragment"><img src="img/app-layer1_01.png" /></div>
            </div>
          </div>

          <div class="fragment" style="width: 65%; margin-top: -40px">
            <img src="img/app-layer2_01.png" />
          </div>

          <aside class="notes">
            <ul>
              <li>
                'Tag' als Direktive, die Funktionalität beeinflussen könnte oder
                Konfiguration der Komponente beinhaltet, ...
              </li>
              <li>
                'content' als Attribut, das wir anschließend selecten können
              </li>
              <li>
                'content' als Selektor und gleichzeitig als Attribut in Layer1
                kein Problem
              </li>
              <li>
                ContentChild ist erst nach AfterContentInit befüllt, falls
                vorhanden
              </li>
              <li>Klappt nur bei Weitergabe #1, danach ist es undefined.</li>
              <li>
                'descendants' soll alle Elemente durchsuchen, konnte es aber
                noch nie erfolgreich anwenden. Standard: Nur direkte Kinder
              </li>
              <li>
                Weitere Mögliche Option bei ContentChild: 'static' - falls true,
                muss Element ohne Change Detection da sein. Gegenbeispiel: *ngIf
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Neuer Inhalt: Screenshots gegen echten Code austauschen, Beispiel an sich kann bleiben -->
          <h3 style="font-size: 2rem">
            2x ng-content mit gleichem Selektor = 💥
          </h3>

          <div class="flex">
            <div><img src="img/ng-content-projecting-twice_01.png" /></div>

            <div class="flex-column">
              <div class="fragment">
                <img src="img/app-content-twice-both-true_01.png" />
              </div>
              <div class="fragment">
                <img src="img/screenshot-projecting-twice-both-true_01.png" />
              </div>
            </div>

            <div class="flex-column">
              <div class="fragment">
                <img src="img/app-content-twice-second-false_01.png" />
              </div>
              <div class="fragment">
                <img
                  src="img/screenshot-projecting-twice-second-false_01.png"
                />
              </div>
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Ausschneiden aus dem DOM, nur 1x möglich</li>
              <li>Letztes ng-content gewinnt</li>
              <li>
                Egal, ob das ng-content zur Laufzeit überhaupt da ist oder
                nicht!
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Neuer Inhalt: Vereinfachte Code-Beispiele als Code, Rückverweis auf Dependency Injection -->
          <h3 style="font-size: 2rem">Injector & Change Detection Tree</h3>

          <div class="flex-column">
            <div class="flex">
              <div class="fragment">
                <img src="img/ng-content-injector_01.png" />
              </div>
              <div class="fragment">
                <img src="img/ng-content-injector-layer1_01.png" />
              </div>
            </div>
            <div class="flex">
              <div class="fragment">
                <img src="img/ng-content-injector-layer2_01.png" />
              </div>
              <div class="fragment">
                <img src="img/ng-content-injector-text_01.png" />
              </div>
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>
                DOM mit ng-content ist nicht gleich Angular Injector/CD Tree
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Neuer Inhalt: Bild mit "Zusammenfassung" von vorheriger Folie + bestehendes Diagramm -->
          <h3 style="font-size: 2rem">Injector & Change Detection Tree</h3>

          <div class="flex-column">
            <div class="flex">
              <img
                class="fragment"
                src="img/screenshot-ng-content-injector_01.png"
              />

              <blockquote class="fragment" style="font-size: 0.9rem">
                This is working as expected: <br />
                nodes are only "projected" (moved to a different location) but
                everything else works relative to their source (= before
                projection) location.
              </blockquote>
            </div>
            <div class="fragment" style="width: 80%">
              <img src="img/diagram-dom-tree-vs-angular-tree_01.png" />
            </div>
          </div>

          <aside class="notes"></aside>
        </section>

        <section>
          <h3>ng-template</h3>
          <aside class="notes">
            <ul>
              <li>
                Kein Ausschneiden und Einfügen, sondern dynamisches Erzeugen aus
                Vorlagen
              </li>
              <li>
                Alles, was mit ng-content geht, geht auch mit ng-template, aber
                ggf. mehr Code
              </li>
              <li>Mehr Möglichkeiten als ng-content</li>
            </ul>
          </aside>
        </section>

          <!-- Beispiel mit *ngIf und template als else -->

        <section>
          <!-- Neuer Inhalt: Vereinfachtes Codebeispiel, ngTemplateOutlet ohne first und index, nur mit $implicit, und nicht alles item nennen? -->
          <h3>ngTemplateOutlet</h3>

          <div class="flex">
            <div class="flex-column" style="align-items: center">
              <div class="fragment" data-fragment-index="1">
                <img src="img/ng-template-context_01.png" />
              </div>
              <div class="fragment" data-fragment-index="3" style="width: 50%">
                <img src="img/screenshot-list-different-ng-template_01.png" />
              </div>
            </div>

            <div class="fragment" data-fragment-index="2">
              <img src="img/list-different-ng-template_01.png" />
            </div>
          </div>
        </section>

        <section>
          <h3>Lifecycle</h3>

          <!-- Die Folie kann glaub ich so bleiben? Vielleicht Code im neuen Stil -->

          <div class="flex">
            <div class="fragment" style="width: 80%">
              <img src="img/list-different-ng-template_01.png" />
            </div>
            <div class="fragment">
              <img src="img/list-different-ng-template-lifecycle_01.png" />
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Gleiche Komponente wie gerade eben</li>
              <li>
                Nur der dynamische Teil mit reingegebenem Template interessant
              </li>
              <li>
                Direkt vor "ngAfterViewInit" wird der dynamische Teil komplett
                erzeugt und initialisiert
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Eigene Folie für TemplateTypeDirective und Beispiel-Templates mit Screenshots der beiden! -->
          <h3 style="font-size: 2rem">Verschiedene Templates mit Auswahl</h3>

          <!-- Zweite Folie: Selektion via QueryList und Templates in Map speichern -->
          <!-- Dritte Folie: Template und Endergebnis -->
          <div class="flex">
            <div class="flex-column">
              <div class="fragment">
                <img src="img/ng-template-multiple-types_01.png" />
              </div>
              <div class="fragment">
                <img src="img/template-type-directive_01.png" />
              </div>
            </div>
            <div class="fragment">
              <img src="img/list-multiple-templates_01.png" />
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>
                Gibt es kein passendes Template, wird stillschweigend einfach
                nichts angezeigt
              </li>
              <li>
                If you are listening to QueryList's observable updates things
                are not as clear cut: updates are often late, and already
                removed things are still showing up - and the order is never
                guaranteed!
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Neuer Code-Stil, zweite Folie: Bild DOM-Tree&Angular-Tree: Alles wie es sein soll -->
          <h3 style="font-size: 2rem">Injector Tree</h3>

          <div class="flex" style="margin-top: -40px">
            <div class="flex-column">
              <div class="fragment">
                <img src="img/ng-template-injector_01.png" />
              </div>
              <div class="fragment" style="margin-top: -40px">
                <img src="img/list-injector_01.png" />
              </div>
            </div>
            <div class="flex-column">
              <div class="fragment">
                <img src="img/list-item-injector_01.png" />
              </div>
              <div class="fragment">
                <img src="img/screenshot-list-item-injector_01.png" />
              </div>
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Hier wird nichts ausgeschnitten und verschoben</li>
              <li>Injector verhält sich so, wie erwartet</li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- *ngFor zeigen/erklären und default trackBy mit GIF -->
          <h3>trackBy</h3>
          <span style="font-size: 0.5rem" class="placeholder"
            >TODO: trackBy mit in Bild übernehmen, damit man weiß, wo es
            hinkommt</span
          >

          <div class="flex">
            <div class="fragment">
              <img src="img/ng-template-wrapper-trackBy_01.png" />
            </div>

            <div class="flex-column fragment">
              <div>
                <img src="img/app-list-injector-default-trackBy_01.png" />
              </div>
              <div>
                <img src="img/no-trackBy-items-get-recreated_01_endless.gif" />
              </div>
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Angepasstes trackBy, z.B. auf eine id</li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- angepasstes trackBy zeigen, GIF mit Jetzt funktioniert's -->
          <h3>trackBy</h3>

          <div class="flex-column">
            <div class="fragment">
              <img src="img/app-list-injector-custom-trackBy_01.png" />
            </div>
            <div class="fragment">
              <img src="img/custom-trackBy-items-kept_01_endless.gif" />
            </div>
          </div>

          <aside class="notes">
            <ul>
              <li>Angepasstes trackBy, z.B. auf eine id</li>
            </ul>
          </aside>
        </section>

        <section>
          <!-- Neue Folie: Kurze Einführung Google Performance Tab, Screenshot wo zu finden, Flamecharts Makroansicht zeigen -->
          <!-- Dann erst Beispiel aus Projekt rangezoomed -->
          <h3>Performance</h3>

          <img src="img/performance-creating-items_01.png" />

          <aside class="notes">
            <ul>
              <li>Niemals ohne OnPush arbeiten</li>
              <li>Zerstören/Aufbauen teuer: custom trackBy</li>
              <li>Komponenten/Direktiven möglichst schlank halten</li>
              <li>Jede Direktive, jeder Input, jedes ngIf kostet</li>
              <li>rx-angular</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Doku-Links</h3>

          <a
            href="https://angular.io/guide/structural-directives#the-ng-template"
            >Offizielle Doku zu ng-template</a
          >
          <br />
          <br />
          <a
            href="https://medium.com/claritydesignsystem/ng-content-the-hidden-docs-96a29d70d11b"
            >ng-content: The hidden docs</a
          >
          <br />
          <br />
          <a
            href="https://blog.angular-university.io/angular-ng-template-ng-container-ngtemplateoutlet/"
            >Angular ng-template, ng-container and ngTemplateOutlet - The
            Complete Guide To Angular Templates</a
          >
          <br />
          <br />
        </section>

        <section>
          <h3 class="placeholder">Fragen/Danke</h3>
          TODO: Kontaktdaten & Bild
        </section>
      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.configure({
        transition: "none",
        history: "true",
      });
      Reveal.initialize({
        hashOneBasedIndex: false,
        controls: false,
        slideNumber: "c/t",
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
